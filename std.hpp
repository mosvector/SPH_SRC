/* Autogenerated header */
#pragma once

class/*or struct*/ std
{
public:
  // Nested containers:
  template<typename T1  >
  class _List_iterator
  {
  public:
  };
#if 0 // Instances:
// <class std::_List_val<struct std::_List_simple_types<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>>>
#if 0
  template<>
  class _List_iterator<class std::_List_val<struct std::_List_simple_types<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>>>
  {
  public:
  };
#endif
#endif


  template<typename T1  >
  struct _List_simple_types
  {
  public:
  };
#if 0 // Instances:
// <class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>
#if 0
  template<>
  struct _List_simple_types<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>
  {
  public:
  };
#endif
#endif


  template<typename T1  >
  class _List_val
  {
  public:
  };
#if 0 // Instances:
// <struct std::_List_simple_types<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>>
#if 0
  template<>
  class _List_val<struct std::_List_simple_types<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>>
  {
  public:
  };
#endif
#endif


  class/*or struct*/ _Locinfo
  {
    // Functions:
    public: struct _Cvtvec _Getcvt(void) const
    public: unsigned short const * _W_Getdays(void) const
    public: unsigned short const * _W_Getmonths(void) const
  public:
  };

  template<typename T1  >
  class/*or struct*/ _Ref_count
  {
  public:
  };
#if 0 // Instances:
// <class `anonymous namespace'::StatisticsProcessor>
#if 0
  template<>
  class/*or struct*/ _Ref_count<class `anonymous namespace'::StatisticsProcessor> : public _Ref_count_base
  {
    // VFTable. Offset=0, Size=4, Start=0
    // Corresponding base: std::_Ref_count_base
    // Owner: SophisSystem.dll
    // Added virtual functions:
    public: virtual void unknown_vf_0_0(void); // 0
    public: virtual void unknown_vf_0_1(void); // 1
    public: virtual void unknown_vf_0_2(void); // 2
    public: virtual void unknown_vf_0_3(void); // 3
    // VFTable with 0 offset end

  public:
  };
#endif
// <class sphSystem::comm::ChannelReceiveThread>
#if 0
  template<>
  class/*or struct*/ _Ref_count<class sphSystem::comm::ChannelReceiveThread> : public _Ref_count_base
  {
    // VFTable. Offset=0, Size=4, Start=0
    // Corresponding base: std::_Ref_count_base
    // Owner: SophisSystem.dll
    // Added virtual functions:
    public: virtual void unknown_vf_0_0(void); // 0
    public: virtual void unknown_vf_0_1(void); // 1
    public: virtual void unknown_vf_0_2(void); // 2
    public: virtual void unknown_vf_0_3(void); // 3
    // VFTable with 0 offset end

  public:
  };
#endif
// <class sphSystem::comm::ChannelSendThread>
#if 0
  template<>
  class/*or struct*/ _Ref_count<class sphSystem::comm::ChannelSendThread> : public _Ref_count_base
  {
    // VFTable. Offset=0, Size=4, Start=0
    // Corresponding base: std::_Ref_count_base
    // Owner: SophisSystem.dll
    // Added virtual functions:
    public: virtual void unknown_vf_0_0(void); // 0
    public: virtual void unknown_vf_0_1(void); // 1
    public: virtual void unknown_vf_0_2(void); // 2
    public: virtual void unknown_vf_0_3(void); // 3
    // VFTable with 0 offset end

  public:
  };
#endif
// <class sphSystem::comm::SimpleChannelReceiveThread>
#if 0
  template<>
  class/*or struct*/ _Ref_count<class sphSystem::comm::SimpleChannelReceiveThread> : public _Ref_count_base
  {
    // VFTable. Offset=0, Size=4, Start=0
    // Corresponding base: std::_Ref_count_base
    // Owner: SophisSystem.dll
    // Added virtual functions:
    public: virtual void unknown_vf_0_0(void); // 0
    public: virtual void unknown_vf_0_1(void); // 1
    public: virtual void unknown_vf_0_2(void); // 2
    public: virtual void unknown_vf_0_3(void); // 3
    // VFTable with 0 offset end

  public:
  };
#endif
// <class sphSystem::comm::SimpleChannelSendThread>
#if 0
  template<>
  class/*or struct*/ _Ref_count<class sphSystem::comm::SimpleChannelSendThread> : public _Ref_count_base
  {
    // VFTable. Offset=0, Size=4, Start=0
    // Corresponding base: std::_Ref_count_base
    // Owner: SophisSystem.dll
    // Added virtual functions:
    public: virtual void unknown_vf_0_0(void); // 0
    public: virtual void unknown_vf_0_1(void); // 1
    public: virtual void unknown_vf_0_2(void); // 2
    public: virtual void unknown_vf_0_3(void); // 3
    // VFTable with 0 offset end

  public:
  };
#endif
// <class sphSystem::logger::AutoShiftWorkerThread>
#if 0
  template<>
  class/*or struct*/ _Ref_count<class sphSystem::logger::AutoShiftWorkerThread> : public _Ref_count_base
  {
    // VFTable. Offset=0, Size=4, Start=0
    // Corresponding base: std::_Ref_count_base
    // Owner: SophisSystem.dll
    // Added virtual functions:
    public: virtual void unknown_vf_0_0(void); // 0
    public: virtual void unknown_vf_0_1(void); // 1
    public: virtual void unknown_vf_0_2(void); // 2
    public: virtual void unknown_vf_0_3(void); // 3
    // VFTable with 0 offset end

  public:
  };
#endif
// <class sphSystem::server::AutoShutDownThread>
#if 0
  template<>
  class/*or struct*/ _Ref_count<class sphSystem::server::AutoShutDownThread> : public _Ref_count_base
  {
    // VFTable. Offset=0, Size=4, Start=0
    // Corresponding base: std::_Ref_count_base
    // Owner: SophisSystem.dll
    // Added virtual functions:
    public: virtual void unknown_vf_0_0(void); // 0
    public: virtual void unknown_vf_0_1(void); // 1
    public: virtual void unknown_vf_0_2(void); // 2
    public: virtual void unknown_vf_0_3(void); // 3
    // VFTable with 0 offset end

  public:
  };
#endif
// <class sphSystem::server::ProgramExitWatcherThread>
#if 0
  template<>
  class/*or struct*/ _Ref_count<class sphSystem::server::ProgramExitWatcherThread> : public _Ref_count_base
  {
    // VFTable. Offset=0, Size=4, Start=0
    // Corresponding base: std::_Ref_count_base
    // Owner: SophisSystem.dll
    // Added virtual functions:
    public: virtual void unknown_vf_0_0(void); // 0
    public: virtual void unknown_vf_0_1(void); // 1
    public: virtual void unknown_vf_0_2(void); // 2
    public: virtual void unknown_vf_0_3(void); // 3
    // VFTable with 0 offset end

  public:
  };
#endif
// <class sphSystem::thread::MultiActionThread>
#if 0
  template<>
  class/*or struct*/ _Ref_count<class sphSystem::thread::MultiActionThread> : public _Ref_count_base
  {
    // VFTable. Offset=0, Size=4, Start=0
    // Corresponding base: std::_Ref_count_base
    // Owner: SophisSystem.dll
    // Added virtual functions:
    public: virtual void unknown_vf_0_0(void); // 0
    public: virtual void unknown_vf_0_1(void); // 1
    public: virtual void unknown_vf_0_2(void); // 2
    public: virtual void unknown_vf_0_3(void); // 3
    // VFTable with 0 offset end

  public:
  };
#endif
// <class sphSystem::thread::RunnableWorkerThread>
#if 0
  template<>
  class/*or struct*/ _Ref_count<class sphSystem::thread::RunnableWorkerThread> : public _Ref_count_base
  {
    // VFTable. Offset=0, Size=4, Start=0
    // Corresponding base: std::_Ref_count_base
    // Owner: SophisSystem.dll
    // Added virtual functions:
    public: virtual void unknown_vf_0_0(void); // 0
    public: virtual void unknown_vf_0_1(void); // 1
    public: virtual void unknown_vf_0_2(void); // 2
    public: virtual void unknown_vf_0_3(void); // 3
    // VFTable with 0 offset end

  public:
  };
#endif
#endif


  class/*or struct*/ _Ref_count_base
  {
  public:
  };

  template<typename T1  >
  struct _Simple_types
  {
  public:
  };
#if 0 // Instances:
// <class sophisTools::base::RefCountHandle<class sophisTools::io::Library>>
#if 0
  template<>
  struct _Simple_types<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>>
  {
  public:
  };
#endif
#endif


  template<typename T0, typename T1, typename T2, typename T3, typename T5  >
  class _Tmap_traits
  {
  public:
  };
#if 0 // Instances:
// <class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>, 0>
#if 0
  template<>
  class _Tmap_traits<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>, 0>
  {
  public:
  };
#endif
// <class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, unsigned __int64, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, unsigned __int64>>, 0>
#if 0
  template<>
  class _Tmap_traits<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, unsigned __int64, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, unsigned __int64>>, 0>
  {
  public:
  };
#endif
// <unsigned long, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>, struct std::less<unsigned long>, class std::allocator<struct std::pair<unsigned long const, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>>>, 1>
#if 0
  template<>
  class _Tmap_traits<unsigned long, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>, struct std::less<unsigned long>, class std::allocator<struct std::pair<unsigned long const, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>>>, 1>
  {
  public:
  };
#endif
#endif


  template<typename T1  >
  class/*or struct*/ _Tree
  {
  public:
  };
#if 0 // Instances:
// <class std::_Tmap_traits<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>, 0>>
#if 0
  template<>
  class/*or struct*/ _Tree<class std::_Tmap_traits<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>, 0>>
  {
  public:
  };
#endif
// <class std::_Tmap_traits<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, unsigned __int64, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, unsigned __int64>>, 0>>
#if 0
  template<>
  class/*or struct*/ _Tree<class std::_Tmap_traits<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, unsigned __int64, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, unsigned __int64>>, 0>>
  {
  public:
  };
#endif
// <class std::_Tmap_traits<unsigned long, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>, struct std::less<unsigned long>, class std::allocator<struct std::pair<unsigned long const, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>>>, 1>>
#if 0
  template<>
  class/*or struct*/ _Tree<class std::_Tmap_traits<unsigned long, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>, struct std::less<unsigned long>, class std::allocator<struct std::pair<unsigned long const, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>>>, 1>>
  {
  public:
  };
#endif
#endif


  template<typename T1  >
  class _Tree_const_iterator
  {
  public:
  };
#if 0 // Instances:
// <class std::_Tree_val<struct std::_Tree_simple_types<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>>>
#if 0
  template<>
  class _Tree_const_iterator<class std::_Tree_val<struct std::_Tree_simple_types<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>>>
  {
  public:
  };
#endif
#endif


  template<typename T1  >
  class _Tree_iterator
  {
  public:
  };
#if 0 // Instances:
// <class std::_Tree_val<struct std::_Tree_simple_types<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>>>
#if 0
  template<>
  class _Tree_iterator<class std::_Tree_val<struct std::_Tree_simple_types<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>>>
  {
  public:
  };
#endif
#endif


  template<typename T1  >
  struct _Tree_simple_types
  {
  public:
  };
#if 0 // Instances:
// <struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>
#if 0
  template<>
  struct _Tree_simple_types<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>
  {
  public:
  };
#endif
#endif


  template<typename T1  >
  class _Tree_val
  {
  public:
  };
#if 0 // Instances:
// <struct std::_Tree_simple_types<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>>
#if 0
  template<>
  class _Tree_val<struct std::_Tree_simple_types<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>>
  {
  public:
  };
#endif
#endif


  template<typename T1  >
  class _Vector_iterator
  {
  public:
  };
#if 0 // Instances:
// <class std::_Vector_val<struct std::_Simple_types<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>>>>
#if 0
  template<>
  class _Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>>>>
  {
  public:
  };
#endif
#endif


  template<typename T1  >
  class _Vector_val
  {
  public:
  };
#if 0 // Instances:
// <struct std::_Simple_types<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>>>
#if 0
  template<>
  class _Vector_val<struct std::_Simple_types<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>>>
  {
  public:
  };
#endif
#endif


  template<typename T1  >
  class allocator
  {
  public:
  };
#if 0 // Instances:
// <char>
#if 0
  template<>
  class allocator<char>
  {
  public:
  };
#endif
// <class sophisTools::base::RefCountHandle<class sophis::tools::util::NotificationListener<struct sophis::tools::util::Worker::JobTerminatedEvent>>>
#if 0
  template<>
  class allocator<class sophisTools::base::RefCountHandle<class sophis::tools::util::NotificationListener<struct sophis::tools::util::Worker::JobTerminatedEvent>>>
  {
  public:
  };
#endif
// <class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>
#if 0
  template<>
  class allocator<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>
  {
  public:
  };
#endif
// <class sophisTools::base::RefCountHandle<class sophisTools::comm::QuoteInfo>>
#if 0
  template<>
  class allocator<class sophisTools::base::RefCountHandle<class sophisTools::comm::QuoteInfo>>
  {
  public:
  };
#endif
// <class sophisTools::base::RefCountHandle<class sophisTools::io::Library>>
#if 0
  template<>
  class allocator<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>>
  {
  public:
  };
#endif
// <class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>
#if 0
  template<>
  class allocator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>
  {
  public:
  };
#endif
// <struct sophisTools::logger::filterConstraint>
#if 0
  template<>
  class allocator<struct sophisTools::logger::filterConstraint>
  {
  public:
  };
#endif
// <struct sophisTools::net::SelectReactor::HandlerInfo>
#if 0
  template<>
  class allocator<struct sophisTools::net::SelectReactor::HandlerInfo>
  {
  public:
  };
#endif
// <struct sphSystem::plugin::ListElement>
#if 0
  template<>
  class allocator<struct sphSystem::plugin::ListElement>
  {
  public:
  };
#endif
// <struct std::pair<class sophisTools::time::Time24 const, class sophisTools::base::RefCountHandle<class sphSystem::thread::ScheduledAction>>>
#if 0
  template<>
  class allocator<struct std::pair<class sophisTools::time::Time24 const, class sophisTools::base::RefCountHandle<class sphSystem::thread::ScheduledAction>>>
  {
  public:
  };
#endif
// <struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>
#if 0
  template<>
  class allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>
  {
  public:
  };
#endif
// <struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, unsigned __int64>>
#if 0
  template<>
  class allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, unsigned __int64>>
  {
  public:
  };
#endif
// <struct std::pair<unsigned long const, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>>>
#if 0
  template<>
  class allocator<struct std::pair<unsigned long const, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>>>
  {
  public:
  };
#endif
// <unsigned char>
#if 0
  template<>
  class allocator<unsigned char>
  {
  public:
  };
#endif
#endif


  class/*or struct*/ bad_alloc : public exception
  {
    // VFTable. Offset=0, Size=2, Start=2
    // Corresponding base: std::exception
    // Owner: SophisSystem.dll
    // VFTable with 0 offset end

  public:
  };

  class/*or struct*/ bad_array_new_length : public bad_alloc
  {
    // VFTable. Offset=0, Size=2, Start=2
    // Corresponding base: std::bad_alloc
    // Owner: SophisSystem.dll
    // VFTable with 0 offset end

  public:
  };

  class/*or struct*/ bad_cast : public exception
  {
    // VFTable. Offset=0, Size=2, Start=2
    // Corresponding base: std::exception
    // Owner: SophisSystem.dll
    // VFTable with 0 offset end

  public:
  };

  class/*or struct*/ bad_weak_ptr : public exception
  {
    // VFTable. Offset=0, Size=2, Start=2
    // Corresponding base: std::exception
    // Owner: SophisSystem.dll
    // VFTable with 0 offset end

  public:
  };

  template<typename T0, typename T2  >
  class/*or struct*/ basic_ios
  {
  public:
  };
#if 0 // Instances:
// <char, struct std::char_traits<char>>
#if 0
  template<>
  class/*or struct*/ basic_ios<char, struct std::char_traits<char>>
  {
    // Functions:
    protected: std::basic_ios<char, struct std::char_traits<char>>::basic_ios<char, struct std::char_traits<char>>(void)
    public: void std::basic_ios<char, struct std::char_traits<char>>::setstate(int, bool)
#if 0 // All found virtual functions names:
    public: virtual std::basic_ios<char, struct std::char_traits<char>>::~basic_ios<char, struct std::char_traits<char>>(void)
#endif

  public:
  };
#endif
#endif


  template<typename T0, typename T2  >
  class basic_istream
  {
  public:
  };
#if 0 // Instances:
// <char, struct std::char_traits<char>>
#if 0
  template<>
  class basic_istream<char, struct std::char_traits<char>>
  {
    // Functions:
    public: std::basic_istream<char, struct std::char_traits<char>>::basic_istream<char, struct std::char_traits<char>>(class std::basic_streambuf<char, struct std::char_traits<char>> *, bool)
    public: class std::basic_istream<char, struct std::char_traits<char>> & std::basic_istream<char, struct std::char_traits<char>>::operator>>(short &)
    public: class std::basic_istream<char, struct std::char_traits<char>> & std::basic_istream<char, struct std::char_traits<char>>::operator>>(unsigned short &)
    public: class std::basic_istream<char, struct std::char_traits<char>> & std::basic_istream<char, struct std::char_traits<char>>::operator>>(long &)
    public: class std::basic_istream<char, struct std::char_traits<char>> & std::basic_istream<char, struct std::char_traits<char>>::operator>>(unsigned long &)
    public: class std::basic_istream<char, struct std::char_traits<char>> & std::basic_istream<char, struct std::char_traits<char>>::operator>>(float &)
    public: class std::basic_istream<char, struct std::char_traits<char>> & std::basic_istream<char, struct std::char_traits<char>>::operator>>(double &)
    public: class std::basic_istream<char, struct std::char_traits<char>> & std::basic_istream<char, struct std::char_traits<char>>::operator>>(__int64 &)
    public: class std::basic_istream<char, struct std::char_traits<char>> & std::basic_istream<char, struct std::char_traits<char>>::operator>>(unsigned __int64 &)
    public: bool std::basic_istream<char, struct std::char_traits<char>>::_Ipfx(bool)
#if 0 // All found virtual functions names:
    public: virtual std::basic_istream<char, struct std::char_traits<char>>::~basic_istream<char, struct std::char_traits<char>>(void)
#endif

  public:
  };
#endif
#endif


#if 0
  template<>
  class basic_istream<char, struct std::char_traits<char>>
  {
  public:
  };
#endif

  template<typename T0, typename T1, typename T3  >
  class/*or struct*/ basic_istringstream
  {
  public:
  };
#if 0 // Instances:
// <char, struct std::char_traits<char>, class std::allocator<char>>
#if 0
  template<>
  class/*or struct*/ basic_istringstream<char, struct std::char_traits<char>, class std::allocator<char>>
  {
    // VFTable. Offset=144, Size=1, Start=0
    // Owner: SophisSystem.dll
    // Added virtual functions:
#if 0 // Warning: There are virtual functions probably from base class.
    public: virtual void unknown_vf_144_0(void); // 0
#endif
    // VFTable with 144 offset end

  public:
  };
#endif
#endif


  template<typename T0, typename T2  >
  class basic_ostream
  {
  public:
  };
#if 0 // Instances:
// <char, struct std::char_traits<char>>
#if 0
  template<>
  class basic_ostream<char, struct std::char_traits<char>>
  {
    // Functions:
    public: std::basic_ostream<char, struct std::char_traits<char>>::basic_ostream<char, struct std::char_traits<char>>(class std::basic_streambuf<char, struct std::char_traits<char>> *, bool)
    public: class std::basic_ostream<char, struct std::char_traits<char>> & std::basic_ostream<char, struct std::char_traits<char>>::operator<<(short)
    public: class std::basic_ostream<char, struct std::char_traits<char>> & std::basic_ostream<char, struct std::char_traits<char>>::operator<<(unsigned short)
    public: class std::basic_ostream<char, struct std::char_traits<char>> & std::basic_ostream<char, struct std::char_traits<char>>::operator<<(int)
    public: class std::basic_ostream<char, struct std::char_traits<char>> & std::basic_ostream<char, struct std::char_traits<char>>::operator<<(unsigned int)
    public: class std::basic_ostream<char, struct std::char_traits<char>> & std::basic_ostream<char, struct std::char_traits<char>>::operator<<(long)
    public: class std::basic_ostream<char, struct std::char_traits<char>> & std::basic_ostream<char, struct std::char_traits<char>>::operator<<(unsigned long)
    public: class std::basic_ostream<char, struct std::char_traits<char>> & std::basic_ostream<char, struct std::char_traits<char>>::operator<<(float)
    public: class std::basic_ostream<char, struct std::char_traits<char>> & std::basic_ostream<char, struct std::char_traits<char>>::operator<<(double)
    public: class std::basic_ostream<char, struct std::char_traits<char>> & std::basic_ostream<char, struct std::char_traits<char>>::operator<<(class std::ios_base & (__cdecl *)(class std::ios_base &))
    public: class std::basic_ostream<char, struct std::char_traits<char>> & std::basic_ostream<char, struct std::char_traits<char>>::operator<<(__int64)
    public: class std::basic_ostream<char, struct std::char_traits<char>> & std::basic_ostream<char, struct std::char_traits<char>>::operator<<(unsigned __int64)
    public: class std::basic_ostream<char, struct std::char_traits<char>> & std::basic_ostream<char, struct std::char_traits<char>>::operator<<(bool)
    public: void std::basic_ostream<char, struct std::char_traits<char>>::`vbase dtor'(void)
    public: void std::basic_ostream<char, struct std::char_traits<char>>::_Osfx(void)
    public: class std::basic_ostream<char, struct std::char_traits<char>> & std::basic_ostream<char, struct std::char_traits<char>>::flush(void)
#if 0 // All found virtual functions names:
    public: virtual std::basic_ostream<char, struct std::char_traits<char>>::~basic_ostream<char, struct std::char_traits<char>>(void)
#endif

  public:
  };
#endif
#endif


#if 0
  template<>
  class basic_ostream<char, struct std::char_traits<char>>
  {
  public:
  };
#endif

  template<typename T0, typename T1, typename T3  >
  class/*or struct*/ basic_ostringstream
  {
  public:
  };
#if 0 // Instances:
// <char, struct std::char_traits<char>, class std::allocator<char>>
#if 0
  template<>
  class/*or struct*/ basic_ostringstream<char, struct std::char_traits<char>, class std::allocator<char>>
  {
    // VFTable. Offset=136, Size=1, Start=0
    // Owner: SophisSystem.dll
    // Added virtual functions:
#if 0 // Warning: There are virtual functions probably from base class.
    public: virtual void unknown_vf_136_0(void); // 0
#endif
    // VFTable with 136 offset end

  public:
  };
#endif
#endif


  template<typename T0, typename T2  >
  class basic_streambuf
  {
  public:
  };
#if 0 // Instances:
// <char, struct std::char_traits<char>>
#if 0
  template<>
  class basic_streambuf<char, struct std::char_traits<char>>
  {
    // Functions:
    protected: std::basic_streambuf<char, struct std::char_traits<char>>::basic_streambuf<char, struct std::char_traits<char>>(void)
    protected: char * std::basic_streambuf<char, struct std::char_traits<char>>::_Pninc(void)
    public: int std::basic_streambuf<char, struct std::char_traits<char>>::sbumpc(void)
    public: int std::basic_streambuf<char, struct std::char_traits<char>>::sputc(char)
    public: __int64 std::basic_streambuf<char, struct std::char_traits<char>>::sputn(char const *, __int64)
#if 0 // All found virtual functions names:
    public: virtual std::basic_streambuf<char, struct std::char_traits<char>>::~basic_streambuf<char, struct std::char_traits<char>>(void)
    public: virtual void std::basic_streambuf<char, struct std::char_traits<char>>::_Lock(void)
    public: virtual void std::basic_streambuf<char, struct std::char_traits<char>>::_Unlock(void)
    protected: virtual void std::basic_streambuf<char, struct std::char_traits<char>>::imbue(class std::locale const &)
    protected: virtual class std::basic_streambuf<char, struct std::char_traits<char>> * std::basic_streambuf<char, struct std::char_traits<char>>::setbuf(char *, __int64)
    protected: virtual __int64 std::basic_streambuf<char, struct std::char_traits<char>>::showmanyc(void)
    protected: virtual int std::basic_streambuf<char, struct std::char_traits<char>>::sync(void)
    protected: virtual int std::basic_streambuf<char, struct std::char_traits<char>>::uflow(void)
    protected: virtual __int64 std::basic_streambuf<char, struct std::char_traits<char>>::xsgetn(char *, __int64)
    protected: virtual __int64 std::basic_streambuf<char, struct std::char_traits<char>>::xsputn(char const *, __int64)
#endif

    // VFTable. Offset=0, Size=15, Start=0
    // Added virtual functions:
    public: virtual std::basic_streambuf<char, struct std::char_traits<char>>::~basic_streambuf<char, struct std::char_traits<char>>(void); // 0
    public: virtual void std::basic_streambuf<char, struct std::char_traits<char>>::_Lock(void); // 1
    public: virtual void std::basic_streambuf<char, struct std::char_traits<char>>::_Unlock(void); // 2
    public: virtual void unknown_vf_0_3(void); // 3
    public: virtual void unknown_vf_0_4(void); // 4
    protected: virtual __int64 std::basic_streambuf<char, struct std::char_traits<char>>::showmanyc(void); // 5
    public: virtual void unknown_vf_0_6(void); // 6
    protected: virtual int std::basic_streambuf<char, struct std::char_traits<char>>::uflow(void); // 7
    protected: virtual __int64 std::basic_streambuf<char, struct std::char_traits<char>>::xsgetn(char *, __int64); // 8
    protected: virtual __int64 std::basic_streambuf<char, struct std::char_traits<char>>::xsputn(char const *, __int64); // 9
    public: virtual void unknown_vf_0_10(void); // 10
    public: virtual void unknown_vf_0_11(void); // 11
    protected: virtual class std::basic_streambuf<char, struct std::char_traits<char>> * std::basic_streambuf<char, struct std::char_traits<char>>::setbuf(char *, __int64); // 12
    protected: virtual int std::basic_streambuf<char, struct std::char_traits<char>>::sync(void); // 13
    protected: virtual void std::basic_streambuf<char, struct std::char_traits<char>>::imbue(class std::locale const &); // 14
    // VFTable with 0 offset end

  public:
  };
#endif
#endif


#if 0
  template<>
  class basic_streambuf<char, struct std::char_traits<char>>
  {
  public:
  };
#endif

  template<typename T0, typename T1, typename T3  >
  class basic_string
  {
  public:
  };
#if 0 // Instances:
// <char, struct std::char_traits<char>, class std::allocator<char>>
#if 0
  template<>
  class basic_string<char, struct std::char_traits<char>, class std::allocator<char>>
  {
  public:
  };
#endif
#endif


#if 0
  template<>
  class basic_string<char, struct std::char_traits<char>, class std::allocator<char>>
  {
  public:
  };
#endif

  template<typename T0, typename T1, typename T3  >
  class basic_stringbuf
  {
  public:
  };
#if 0 // Instances:
// <char, struct std::char_traits<char>, class std::allocator<char>>
#if 0
  template<>
  class basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>> : public basic_streambuf<char, struct std::char_traits<char>>
  {
    // VFTable. Offset=0, Size=15, Start=15
    // Corresponding base: basic_streambuf::basic_streambuf::basic_streambuf<char, struct std::char_traits<char>>
    // Owner: SophisSystem.dll
    // VFTable with 0 offset end

  public:
  };
#endif
#endif


  template<typename T1  >
  struct char_traits
  {
  public:
  };
#if 0 // Instances:
// <char>
#if 0
  template<>
  struct char_traits<char>
  {
  public:
  };
#endif
#endif


  class/*or struct*/ exception
  {
    // VFTable. Offset=0, Size=2, Start=0
    // Owner: SophisSystem.dll
    // Added virtual functions:
    public: virtual void unknown_vf_0_0(void); // 0
    public: virtual void unknown_vf_0_1(void); // 1
    // VFTable with 0 offset end

  public:
  };

  class ios_base
  {
    // Functions:
    public: void exceptions(int)
  public:
  };

  template<typename T1  >
  struct less
  {
  public:
  };
#if 0 // Instances:
// <class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>
#if 0
  template<>
  struct less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>
  {
  public:
  };
#endif
// <unsigned long>
#if 0
  template<>
  struct less<unsigned long>
  {
  public:
  };
#endif
#endif


  template<typename T0, typename T2  >
  class list
  {
  public:
  };
#if 0 // Instances:
// <class sophisTools::base::RefCountHandle<class sophis::tools::util::NotificationListener<struct sophis::tools::util::Worker::JobTerminatedEvent>>, class std::allocator<class sophisTools::base::RefCountHandle<class sophis::tools::util::NotificationListener<struct sophis::tools::util::Worker::JobTerminatedEvent>>>>
#if 0
  template<>
  class/*or struct*/ list<class sophisTools::base::RefCountHandle<class sophis::tools::util::NotificationListener<struct sophis::tools::util::Worker::JobTerminatedEvent>>, class std::allocator<class sophisTools::base::RefCountHandle<class sophis::tools::util::NotificationListener<struct sophis::tools::util::Worker::JobTerminatedEvent>>>>
  {
  public:
  };
#endif
// <class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>, class std::allocator<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>>
#if 0
  template<>
  class/*or struct*/ list<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>, class std::allocator<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>>
  {
    // Functions:
    public: class std::_List_iterator<class std::_List_val<struct std::_List_simple_types<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>>> std::list<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>, class std::allocator<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>>::begin(void)
    public: class std::_List_iterator<class std::_List_val<struct std::_List_simple_types<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>>> std::list<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>, class std::allocator<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>>::end(void)
    public: void std::list<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>, class std::allocator<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>>::pop_front(void)
    public: void std::list<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>, class std::allocator<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>>::push_back(class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker> &&)
    public: void std::list<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>, class std::allocator<class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker>>>::push_back(class sophisTools::base::RefCountHandle<class sophis::tools::util::Worker> const &)
  public:
  };
#endif
// <class sophisTools::base::RefCountHandle<class sophisTools::comm::QuoteInfo>, class std::allocator<class sophisTools::base::RefCountHandle<class sophisTools::comm::QuoteInfo>>>
#if 0
  template<>
  class list<class sophisTools::base::RefCountHandle<class sophisTools::comm::QuoteInfo>, class std::allocator<class sophisTools::base::RefCountHandle<class sophisTools::comm::QuoteInfo>>>
  {
  public:
  };
#endif
// <struct sophisTools::logger::filterConstraint, class std::allocator<struct sophisTools::logger::filterConstraint>>
#if 0
  template<>
  class list<struct sophisTools::logger::filterConstraint, class std::allocator<struct sophisTools::logger::filterConstraint>>
  {
  public:
  };
#endif
// <struct sophisTools::net::SelectReactor::HandlerInfo, class std::allocator<struct sophisTools::net::SelectReactor::HandlerInfo>>
#if 0
  template<>
  class list<struct sophisTools::net::SelectReactor::HandlerInfo, class std::allocator<struct sophisTools::net::SelectReactor::HandlerInfo>>
  {
  public:
  };
#endif
// <struct sphSystem::plugin::ListElement, class std::allocator<struct sphSystem::plugin::ListElement>>
#if 0
  template<>
  class/*or struct*/ list<struct sphSystem::plugin::ListElement, class std::allocator<struct sphSystem::plugin::ListElement>>
  {
  public:
  };
#endif
#endif


  class locale
  {
  public:
  };

  template<typename T0, typename T1, typename T2, typename T4  >
  class map
  {
  public:
  };
#if 0 // Instances:
// <class sophisTools::time::Time24, class sophisTools::base::RefCountHandle<class sphSystem::thread::ScheduledAction>, struct sphSystem::thread::less_Time24, class std::allocator<struct std::pair<class sophisTools::time::Time24 const, class sophisTools::base::RefCountHandle<class sphSystem::thread::ScheduledAction>>>>
#if 0
  template<>
  class map<class sophisTools::time::Time24, class sophisTools::base::RefCountHandle<class sphSystem::thread::ScheduledAction>, struct sphSystem::thread::less_Time24, class std::allocator<struct std::pair<class sophisTools::time::Time24 const, class sophisTools::base::RefCountHandle<class sphSystem::thread::ScheduledAction>>>>
  {
  public:
  };
#endif
// <class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>>
#if 0
  template<>
  class/*or struct*/ map<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>> : public _Tree<class std::_Tmap_traits<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>, 0>>
  {
  public:
  };
#endif
// <class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, unsigned __int64, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, unsigned __int64>>>
#if 0
  template<>
  class/*or struct*/ map<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, unsigned __int64, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, unsigned __int64>>> : public _Tree<class std::_Tmap_traits<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, unsigned __int64, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, unsigned __int64>>, 0>>
  {
  public:
  };
#endif
#endif


  template<typename T0, typename T1, typename T2, typename T4  >
  class/*or struct*/ multimap
  {
  public:
  };
#if 0 // Instances:
// <unsigned long, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>, struct std::less<unsigned long>, class std::allocator<struct std::pair<unsigned long const, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>>>>
#if 0
  template<>
  class/*or struct*/ multimap<unsigned long, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>, struct std::less<unsigned long>, class std::allocator<struct std::pair<unsigned long const, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>>>> : public _Tree<class std::_Tmap_traits<unsigned long, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>, struct std::less<unsigned long>, class std::allocator<struct std::pair<unsigned long const, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>>>, 1>>
  {
  public:
  };
#endif
#endif


  template<typename T0, typename T2  >
  struct pair
  {
  public:
  };
#if 0 // Instances:
// <class sophisTools::time::Time24 const, class sophisTools::base::RefCountHandle<class sphSystem::thread::ScheduledAction>>
#if 0
  template<>
  struct pair<class sophisTools::time::Time24 const, class sophisTools::base::RefCountHandle<class sphSystem::thread::ScheduledAction>>
  {
  public:
  };
#endif
// <class std::_Tree_iterator<class std::_Tree_val<struct std::_Tree_simple_types<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>>>, bool>
#if 0
  template<>
  struct pair<class std::_Tree_iterator<class std::_Tree_val<struct std::_Tree_simple_types<struct std::pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>>>, bool>
  {
  public:
  };
#endif
// <class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>
#if 0
  template<>
  struct pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>
  {
  public:
  };
#endif
// <class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, unsigned __int64>
#if 0
  template<>
  struct pair<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const, unsigned __int64>
  {
  public:
  };
#endif
// <unsigned long const, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>>
#if 0
  template<>
  struct pair<unsigned long const, class sophisTools::base::RefCountHandle<class sophisTools::base::Runnable>>
  {
  public:
  };
#endif
#endif


  class/*or struct*/ runtime_error : public exception
  {
    // VFTable. Offset=0, Size=2, Start=2
    // Corresponding base: std::exception
    // Owner: SophisSystem.dll
    // VFTable with 0 offset end

  public:
  };

  template<typename T0, typename T1, typename T3  >
  class set
  {
  public:
  };
#if 0 // Instances:
// <class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>
#if 0
  template<>
  class set<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, struct std::less<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>, class std::allocator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>
  {
  public:
  };
#endif
#endif


  template<typename T1  >
  class shared_ptr
  {
  public:
  };
#if 0 // Instances:
// <class sphSystem::thread::MultiActionThread>
#if 0
  template<>
  class shared_ptr<class sphSystem::thread::MultiActionThread>
  {
  public:
  };
#endif
// <class sphSystem::thread::PollingThread>
#if 0
  template<>
  class shared_ptr<class sphSystem::thread::PollingThread>
  {
  public:
  };
#endif
// <class sphSystem::thread::RunnableBase>
#if 0
  template<>
  class shared_ptr<class sphSystem::thread::RunnableBase>
  {
  public:
  };
#endif
#endif


  template<typename T0, typename T2  >
  class vector
  {
  public:
  };
#if 0 // Instances:
// <class sophisTools::base::RefCountHandle<class sophisTools::io::Library>, class std::allocator<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>>>
#if 0
  template<>
  class/*or struct*/ vector<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>, class std::allocator<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>>>
  {
    // Functions:
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>>>> std::vector<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>, class std::allocator<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>>>::begin(void)
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>>>> std::vector<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>, class std::allocator<class sophisTools::base::RefCountHandle<class sophisTools::io::Library>>>::end(void)
  public:
  };
#endif
// <class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, class std::allocator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>
#if 0
  template<>
  class vector<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>, class std::allocator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>
  {
  public:
  };
#endif
// <unsigned char, class std::allocator<unsigned char>>
#if 0
  template<>
  class vector<unsigned char, class std::allocator<unsigned char>>
  {
  public:
  };
#endif
#endif



  // Functions:
  void _Throw_C_error(int)
  void _Xbad_alloc(void)
  void _Xlength_error(char const *)
  void _Xout_of_range(char const *)
  bool uncaught_exception(void)
public:
};
